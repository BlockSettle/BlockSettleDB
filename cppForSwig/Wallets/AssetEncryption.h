////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  Copyright (C) 2017, goatpig                                               //
//  Distributed under the MIT license                                         //
//  See LICENSE-MIT or https://opensource.org/licenses/MIT                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef _H_ASSET_ENCRYPTION
#define _H_ASSET_ENCRYPTION

#include <memory>
#include "BinaryData.h"
#include "EncryptionUtils.h"
#include "WalletIdTypes.h"

#define KDF_PREFIX                  0xC1
#define KDF_ROMIX_PREFIX            0xC100
#define CIPHER_BYTE                 0xB2

enum CipherType
{
   CipherType_AES,
   CipherType_Serpent
};

class CipherException : public std::runtime_error
{
public:
   CipherException(const std::string& msg) : std::runtime_error(msg)
   {}
};

////////////////////////////////////////////////////////////////////////////////
struct KeyDerivationFunction
{
private:

public:
   KeyDerivationFunction(void)
   {}

   virtual ~KeyDerivationFunction(void) = 0;
   virtual SecureBinaryData deriveKey(
      const SecureBinaryData& rawKey) const = 0;
   virtual bool isSame(KeyDerivationFunction* const) const = 0;

   bool operator<(const KeyDerivationFunction& rhs)
   {
      return getId() < rhs.getId();
   }

   virtual const BinaryData& getId(void) const = 0;
   virtual BinaryData serialize(void) const = 0;
   static std::shared_ptr<KeyDerivationFunction>
      deserialize(const BinaryDataRef&);
};

////////////////////////////////////////////////////////////////////////////////
struct KeyDerivationFunction_Romix : public KeyDerivationFunction
{
private:
   mutable BinaryData id_;
   unsigned iterations_;
   unsigned memTarget_;
   const BinaryData salt_;

private:
   BinaryData computeID(void) const;
   BinaryData initialize(void);

public:
   KeyDerivationFunction_Romix() :
      KeyDerivationFunction(),
      salt_(std::move(initialize()))
   {}

   KeyDerivationFunction_Romix(unsigned iterations, unsigned memTarget,
      SecureBinaryData& salt) :
      KeyDerivationFunction(),
      iterations_(iterations), memTarget_(memTarget), salt_(salt)
   {}

   SecureBinaryData deriveKey(const SecureBinaryData& rawKey) const;
   bool isSame(KeyDerivationFunction* const) const;
   BinaryData serialize(void) const;
   const BinaryData& getId(void) const;
};

struct ClearTextEncryptionKey;

////////////////////////////////////////////////////////////////////////////////
class Cipher
{
   /***
   Carries the cipher type and IV. Not copiable, this is by design to avoid IV
   reuse.

   Also carries identifiers to setup encryption state:
   - kdfId_: to apply the proper kdf on the encryption key
   - encryptionKeyId_: hash of the kdf'd passphrase

   A convenience getCopy method is provided to carry context over to a new 
   object. This call will result in a fresh IV for the copy. IVs are never copied 
   over, the iv has to be generated by the ctor instead.

   It is best to use this class within a std::unique_ptr 
   ***/

private:
   const static PRNG_Fortuna fortuna_;
   const CipherType type_;

protected:
   const BinaryData kdfId_;
   const Armory::Wallets::EncryptionKeyId encryptionKeyId_;
   const SecureBinaryData iv_;

private:
   Cipher(const Cipher&) = delete;
   Cipher& operator=(const Cipher&) = delete;

public:

   //tors
   Cipher(CipherType type, 
      const BinaryData& kdfId,
      const Armory::Wallets::EncryptionKeyId& encryptionKeyId) :
      type_(type), kdfId_(kdfId),
      encryptionKeyId_(encryptionKeyId),
      iv_(generateIV())
   {
      //General purpose ctor, IV is generated on the fly
   }

   Cipher(CipherType type,
      const BinaryData& kdfId,
      const Armory::Wallets::EncryptionKeyId& encryptionKeyId,
      SecureBinaryData& iv) :
      type_(type), kdfId_(kdfId), 
      encryptionKeyId_(encryptionKeyId),
      iv_(std::move(iv))
   {
      //for setting up a cipher object from existing data (i.e. load from disk)

      if(iv_.getSize() != getBlockSize())
         throw CipherException("invalid iv length");
   }

   virtual ~Cipher(void) = 0;

   //locals
   CipherType getType(void) const { return type_; }
   const BinaryData& getKdfId(void) const { return kdfId_; }
   const Armory::Wallets::EncryptionKeyId& getEncryptionKeyId(void) const;
   const SecureBinaryData& getIV(void) const { return iv_; }
   SecureBinaryData generateIV(void) const;
   unsigned getBlockSize(void) const { return getBlockSize(getType()); }

   //virtuals
   virtual BinaryData serialize(void) const = 0;
   virtual std::unique_ptr<Cipher> getCopy(void) const = 0;
   virtual std::unique_ptr<Cipher> getCopy(
      const Armory::Wallets::EncryptionKeyId& keyId) const = 0;
   virtual bool isSame(Cipher* const) const = 0;

   virtual SecureBinaryData encrypt(ClearTextEncryptionKey* const key,
      const BinaryData& kdfId, const SecureBinaryData& data) const = 0;
   virtual SecureBinaryData encrypt(ClearTextEncryptionKey* const key,
      const BinaryData& kdfId, ClearTextEncryptionKey* const data) const = 0;

   virtual SecureBinaryData decrypt(const SecureBinaryData& key,
      const SecureBinaryData& data) const = 0;


   //statics
   static std::unique_ptr<Cipher> deserialize(BinaryRefReader& brr);
   static unsigned getBlockSize(CipherType);
};

////////////////////////////////////////////////////////////////////////////////
class Cipher_AES : public Cipher
{
public:
   //tors
   Cipher_AES(const BinaryData& kdfId,
      const Armory::Wallets::EncryptionKeyId& encryptionKeyId) :
      Cipher(CipherType_AES, kdfId, encryptionKeyId)
   {}

   Cipher_AES(const BinaryData& kdfId,
      const Armory::Wallets::EncryptionKeyId& encryptionKeyId,
      SecureBinaryData& iv) :
      Cipher(CipherType_AES, kdfId, encryptionKeyId, iv)
   {}

   //virtuals
   BinaryData serialize(void) const override;
   std::unique_ptr<Cipher> getCopy(void) const override;
   std::unique_ptr<Cipher> getCopy(
      const Armory::Wallets::EncryptionKeyId& keyId) const override;
   bool isSame(Cipher* const) const override;

   //encrypt
   SecureBinaryData encrypt(ClearTextEncryptionKey* const key,
      const BinaryData& kdfId,
      const SecureBinaryData& data) const override;
   SecureBinaryData encrypt(ClearTextEncryptionKey* const key,
      const BinaryData& kdfId,
      ClearTextEncryptionKey* const data) const override;

   //decrypt
   SecureBinaryData decrypt(const SecureBinaryData& key,
      const SecureBinaryData& data) const override;

   //utils
   unsigned getBlockSize(void) const;
};

#endif